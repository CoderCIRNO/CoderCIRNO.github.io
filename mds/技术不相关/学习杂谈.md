# 杂谈

## 顶端抑制

植物的顶端抑制说不定和回溯算法的思想很像。

## 记一次工作失误

前阵日子进版了一个新feature，大致功能是对人脸ROI做一些处理，运算过程中的溢出问题迄今已经出了三次：两次负值int隐式转换为unsign导致溢出；另一次是divid by zero的溢出（也就是0做了除数）。

最早的那次负溢出是自己检查出来的，我自己测试feature效果的时候发现人脸在边缘的时候，相机会必现crash，于是火速排查原因，进版了修复patch。

第二次还是负溢出，是在我进版一个优化patch之后被测试报出来的。进版前我就隐约感觉这个patch可能有溢出风险，但出于侥幸心理，想当然的认为那种情况不会出现，同时为了尽快进版让主观评测去看效果，就没有细想也没有去管。结果终究还是瞒不过压测，问题第二天就被报出来了。一天之内两个人私聊我，组长也来问这跟我的patch有没有关系——那自然是有。原因排查倒是快（毕竟进版前就有预感），修复patch也很简单，问题没有拖多久，两天就解决了（主要是进版流程慢），在我心里也就没掀起什么波澜。

第三次就是divid by zero，这个溢出风险在函数中一直都有，但最近跑Asan才报出来，因为我的函数只对结果是否溢出做了检查，但运算过程中根本没管。开了ubsan之后，自然是藏不住，大概两三天时间内同事极其疯狂的给我报问题，光是JIRA就给我头上挂了四个，准备进版修复patch的时候，组长还很微妙的问了一句“第二次出问题了？”，我那几天真的人都是麻的，忙着定位问题、忙着出进版patch、忙着跑sanity（居家办公还要借别人的手机跑）、忙着让负责人review、又忙着走verify进稳定版，前前后后忙了四天，才算尘埃落定。

写这个新功能的时候，我一心只顾着怎么实现功能，怎么优化效果，写的时候一行一行倒挺快，唯独心里缺了这根弦——没在意、也没检查是否存在溢出风险，直到问题暴露出来才大拍脑门，不过可能因为我是新人，所幸没有因为这件事被问责。还有就是多亏了日夜不休的压测，及时发现并上报了问题，要是这种残次代码进到用户的手机里，影响了用户体验，那我工程师的脸面可真是要丢尽了……

我明明是科班出身，对溢出原理和危害也明白的透彻，却还是犯这种错误，实在不应该。经过这次风波，至少我之后在写类型转换和除法的时候，会长个心眼吧，这种问题最好在写的时候就彻底规避，免得之后麻烦。

## 北京地铁N号线

今天坐地铁回家的时候偶然发现北京地铁N号线中，是没有3号线、12号线和18号线的。于是开始思索其中的规律。

大概是：如果N是3的整数倍，那么只要N/3不是质数，就不符合条件。

由此，如果北京地铁继续增加N号线，21号线应当存在，因为7是质数；24号线不应存在，因为8不是质数。

## 渐进记法

做程序学好高数真的很重要。。。

## 一个无语的程序风险

今天看AEC代码的时候，发现Flicker相关的过程都是通过一个未初始化指针来调用的，多达三处……当然以我对AEC的熟悉程度这必然不可能是我进版的代码，看了blame是一些负责其他模块的同事为了通过AEC来实现一些功能，比如publish一些meta之类的，就直接加进去了，也没有看上下文。

而这种调用为什么没有出错，我也是大致研究了一番，首先这个成员函数不涉及任何成员变量，通过getInstance拿了一些属于其他类的东西然后做了一些操作最后返回出去，也就是说全过程并不涉及其指针所在地址。而编译时也仅仅是填了些寄存器然后call了一下函数……当然，如果这是个虚函数肯定就段错误了。

存在风险，修复之。